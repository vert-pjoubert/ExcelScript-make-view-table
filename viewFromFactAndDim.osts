function main(workbook: ExcelScript.Workbook) {
  // Visualization Configuration
  const visualizationConfig: VisualizationConfig = {
    outputSheetName: "Project Display",
    factTable: {
      sheetName: "PROJECT_ITEMS",
      keyColumns: ["Line Item ID", "Quantity", "Project ID"],
    },
    dimensionTables: [
      {
        sheetName: "PROJECTS",
        joinColumnFact: "Project ID",
        joinColumnDim: "Project ID",
        selectColumns: ["Project ID", "Project Name"],
      },
      {
        sheetName: "LINE_ITEMS",
        joinColumnFact: "Line Item ID",
        joinColumnDim: "Line Item ID",
        selectColumns: [
          "Line Item ID",
          "Line Item",
          "Description",
          "Price Act",
        ],
      },
    ],
    outputColumns: [
      {
        header: "Project Name",
        source: 'dimension',
        sheetName: "PROJECTS",
        columnName: "Project Name",
        type: "STRING",
      },
      {
        header: "Item ID",
        source: 'dimension',
        sheetName: "LINE_ITEMS",
        columnName: "Line Item ID",
        type: "STRING",
      },
      {
        header: "Line Item",
        source: 'dimension',
        sheetName: "LINE_ITEMS",
        columnName: "Line Item",
        type: "STRING",
      },
      {
        header: "Description",
        source: 'dimension',
        sheetName: "LINE_ITEMS",
        columnName: "Description",
        type: "STRING",
      },
      {
        header: "Quantity",
        source: 'fact',
        columnName: "Quantity",
        type: "NUMBER",
      },
      {
        header: "Price",
        source: 'dimension',
        sheetName: "LINE_ITEMS",
        columnName: "Price Act",
        type: "CURRENCY",
      },
      {
        header: "Total",
        source: 'calculated',
        formula: (row) => Number(row["Quantity"]) * Number(row["Price Act"]),
        type: "CURRENCY",
      },
    ],
    slicers: [
      { columnName: "Project Name" },
      { columnName: "Line Item" },
      // Add more slicers as needed
    ],
  };

  // Prepare the output sheet
  const outputSheet = getOrCreateSheet(workbook, visualizationConfig.outputSheetName);

  // Set the headers
  const headers = visualizationConfig.outputColumns.map(col => col.header);
  outputSheet.getRange("A1").getOffsetRange(0, 0, 1, headers.length).setValues([headers]);

  // Build the visualization data
  const outputData = buildVisualizationData(workbook, visualizationConfig);

  // Write data to the output sheet with formatting
  if (outputData.length > 0) {
    const dataRange = outputSheet.getRange("A2").getResizedRange(outputData.length - 1, headers.length - 1);
    dataRange.setValues(outputData);
    formatOutputColumns(dataRange, visualizationConfig.outputColumns);

    // Convert the data range to a Table object
    const table = outputSheet.addTable(dataRange.getExtendedRange(-1, 0), true);

    // Add slicers if configured
    if (visualizationConfig.slicers?.length) {
      addAndPositionSlicers(workbook, table, visualizationConfig.slicers);
    }
  }

  // Auto-fit columns
  outputSheet.getUsedRange().getFormat().autofitColumns();
}

/**
 * Helper function to get or create a worksheet by name.
 */
const getOrCreateSheet = (workbook: ExcelScript.Workbook, sheetName: string): ExcelScript.Worksheet => {
  let sheet = workbook.getWorksheet(sheetName);
  if (!sheet) {
    sheet = workbook.addWorksheet(sheetName);
  } else {
    sheet.getUsedRange()?.clear();
  }
  return sheet;
};

/**
 * Builds the visualization data by joining fact and dimension tables.
 */
const buildVisualizationData = (
  workbook: ExcelScript.Workbook,
  config: VisualizationConfig
): any[][] => {
  // Load data from fact table
  const factTableData = loadTableData(workbook, config.factTable.sheetName, config.factTable.keyColumns);

  // Load and index data from dimension tables
  const dimensionDataMaps = config.dimensionTables.reduce((acc, dimConfig) => {
    const dimData = loadTableData(workbook, dimConfig.sheetName, dimConfig.selectColumns);
    const joinColumnIndex = dimData.headers.indexOf(dimConfig.joinColumnDim);
    const dimDataMap = new Map(dimData.rows.map(row => [row[joinColumnIndex], row]));
    acc[dimConfig.sheetName] = { dataMap: dimDataMap, headers: dimData.headers };
    return acc;
  }, {} as Record<string, { dataMap: Map<string, any[]>, headers: string[] }>);

  // Build output data
  return factTableData.rows.map(factRow => {
    // Create a row object to hold all data for easy access
    const rowObj = { ...Object.fromEntries(factTableData.headers.map((h, i) => [h, factRow[i]])) };

    // Merge dimension data into row object
    config.dimensionTables.forEach(dimConfig => {
      const dimInfo = dimensionDataMaps[dimConfig.sheetName];
      const factJoinValue = rowObj[dimConfig.joinColumnFact];
      const dimRow = dimInfo.dataMap.get(factJoinValue);
      if (dimRow) {
        Object.assign(rowObj, Object.fromEntries(dimInfo.headers.map((h, i) => [h, dimRow[i]])));
      }
    });

    // Build the output row
    return config.outputColumns.map(colConfig => {
      if (colConfig.source === 'fact' || colConfig.source === 'dimension') {
        return rowObj[colConfig.columnName];
      } else if (colConfig.source === 'calculated' && colConfig.formula) {
        try {
          return colConfig.formula(rowObj);
        } catch (error) {
          console.error(`Error calculating column "${colConfig.header}":`, error);
          return null;
        }
      }
      return null;
    });
  });
};

/**
 * Loads data from a worksheet given the sheet name and selected columns.
 */
const loadTableData = (
  workbook: ExcelScript.Workbook,
  sheetName: string,
  selectColumns: string[]
): { headers: string[], rows: any[][] } => {
  const sheet = workbook.getWorksheet(sheetName);
  const values = sheet.getUsedRange().getValues() as any[][];
  const allHeaders = values[0] as string[];

  // Map selected columns to their indices
  const columnIndices = selectColumns.map(colName => {
    const index = allHeaders.indexOf(colName);
    if (index === -1) throw new Error(`Column "${colName}" not found in sheet "${sheetName}"`);
    return index;
  });

  // Extract headers and rows for selected columns
  const headers = selectColumns;
  const rows = values.slice(1).map(row => columnIndices.map(i => row[i]));

  return { headers, rows };
};

/**
 * Formats the output columns based on their declared types.
 */
const formatOutputColumns = (
  dataRange: ExcelScript.Range,
  outputColumns: OutputColumnConfig[]
): void => {
  outputColumns.forEach((colConfig, index) => {
    const columnRange = dataRange.getColumn(index);
    const formatMap: Record<string, string> = {
      'NUMBER': "0",
      'CURRENCY': "$#,##0.00",
      'DATE': "mm/dd/yyyy",
    };
    const format = formatMap[colConfig.type];
    if (format) {
      columnRange.setNumberFormat(format);
    }
  });
};

/**
 * Adds slicers for specified columns and positions them horizontally to the right of the table.
 */
const addAndPositionSlicers = (
  workbook: ExcelScript.Workbook,
  table: ExcelScript.Table,
  slicersConfig: SlicerConfig[]
): void => {
  // Get the table range position and size
  const tableRange = table.getRange();
  const tableLeft = tableRange.getLeft();
  const tableTop = tableRange.getTop();
  const tableWidth = tableRange.getWidth();

  // Define standard slicer dimensions (in points)
  const slicerWidth = 100;
  const slicerHeight = 150;
  const slicerGap = 10;

  // Initial position for the first slicer
  let currentSlicerLeft = tableLeft + tableWidth + 20;
  let currentSlicerTop = tableTop;

  slicersConfig.forEach(slicerConfig => {
    // Add slicer for the specified column
    const slicer = workbook.addSlicer(table, slicerConfig.columnName, table.getWorksheet());

    // Get slicer shape and set size
    const slicerShape = slicer.getShape();
    slicerShape.setWidth(slicerWidth);
    slicerShape.setHeight(slicerHeight);

    // Position the slicer
    slicerShape.setLeft(currentSlicerLeft);
    slicerShape.setTop(currentSlicerTop);

    // Update positions for next slicer
    currentSlicerLeft += slicerWidth + slicerGap;
  });
};

/**
 * Configuration interfaces.
 */
interface VisualizationConfig {
  outputSheetName: string;
  factTable: FactTableConfig;
  dimensionTables: DimensionTableConfig[];
  outputColumns: OutputColumnConfig[];
  slicers?: SlicerConfig[];
}

interface FactTableConfig {
  sheetName: string;
  keyColumns: string[];
}

interface DimensionTableConfig {
  sheetName: string;
  joinColumnFact: string;
  joinColumnDim: string;
  selectColumns: string[];
}

interface OutputColumnConfig {
  header: string;
  source: 'fact' | 'dimension' | 'calculated';
  sheetName?: string;
  columnName?: string;
  formula?: (row: Record<string, any>) => any;
  type: string;
}

interface SlicerConfig {
  columnName: string;
}
